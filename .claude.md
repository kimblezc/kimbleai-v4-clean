# Claude Code Instructions for KimbleAI

This file contains default rules and workflows that Claude should follow when working on this project.

## üöÄ AUTOMATIC TEST AND DEPLOY (PRIMARY RULE)

**CRITICAL: After completing ANY task, automatically test locally and deploy WITHOUT being asked.**

### Complete Workflow (Execute Automatically)

1. **Test Locally**:
   ```bash
   npm run build
   ```
   - Verify build succeeds with exit code 0
   - Check for errors in build output
   - If build fails, fix issues before proceeding

2. **Bump Version** (choose based on change type):
   ```bash
   # Bug fixes, small tweaks ‚Üí PATCH
   node scripts/bump-version.js patch

   # New features, improvements ‚Üí MINOR (most common)
   node scripts/bump-version.js minor

   # Breaking changes ‚Üí MAJOR
   node scripts/bump-version.js major
   ```

3. **Update Changelog in version.json**:
   - Edit version.json to add brief description of changes
   - Include what was fixed/added/changed

4. **Commit, Push, and Deploy**:
   ```bash
   git add .
   git commit -m "your commit message

chore: Bump to v$(node -p "require('./version.json').version")"
   git push origin master
   vercel --prod --yes
   ```

5. **Verify Deployment on Live Site**:
   - Wait 10-15 seconds for CDN propagation
   - Use WebFetch to check https://www.kimbleai.com
   - Confirm version indicator shows correct version number and git hash
   - Example: "v1.2.0 (5f05079)" should be visible on the page
   - If verification fails, wait 30 seconds and try again
   - Report to user: "‚úÖ Deployed v1.2.0 (5f05079) to www.kimbleai.com - CONFIRMED LIVE"

### When to Execute This Workflow

Execute this complete workflow **WITHOUT being told** after:
- ‚úÖ Fixing bugs
- ‚úÖ Adding features
- ‚úÖ Making improvements
- ‚úÖ Updating documentation that affects functionality
- ‚úÖ Refactoring code
- ‚úÖ Any code changes that should be live on kimbleai.com

**DO NOT WAIT for the user to say "deploy" - just do it automatically!**

### Example Interaction

**User**: "Fix the transcription bug"
**Claude**:
1. Fixes the bug
2. Runs `npm run build` to test locally
3. Runs `node scripts/bump-version.js patch`
4. Updates version.json changelog
5. Commits: "fix: Transcription bug in speaker detection"
6. Pushes to master
7. Deploys with `vercel --prod --yes`
8. Verifies deployment live on www.kimbleai.com using WebFetch
9. Reports: "‚úÖ Fixed transcription bug. Deployed v1.0.1 (abc1234) to www.kimbleai.com - CONFIRMED LIVE"

## Version Control Workflow

**ALWAYS bump version and deploy after making code changes:**

### When Making Changes
After completing ANY code changes (fixes, features, improvements), automatically follow this workflow:

1. **Bump Version** (choose appropriate level):
   ```bash
   # Bug fixes, small tweaks
   node scripts/bump-version.js patch

   # New features, improvements (most common)
   node scripts/bump-version.js minor

   # Breaking changes, major updates
   node scripts/bump-version.js major
   ```

2. **Commit and Deploy**:
   ```bash
   git add version.json
   git commit -m "chore: Bump version to v$(node -p "require('./version.json').version")"
   git push origin master
   vercel --prod --yes
   ```

3. **Verify Deployment**:
   - Check the version indicator in bottom right corner of www.kimbleai.com
   - Format: `v1.0.0 (abc1234)` where abc1234 is git commit hash
   - Should appear on ALL pages after sign-in

### Version Increment Guidelines
- **PATCH (1.0.X)**: Bug fixes, typos, small UI adjustments, documentation
- **MINOR (1.X.0)**: New features, improvements, new API endpoints (MOST COMMON)
- **MAJOR (X.0.0)**: Breaking changes, complete redesigns, architecture changes

### Version Verification
After deployment, the user should see the updated version number in the bottom right corner of any page on www.kimbleai.com. If the version doesn't update:
1. Wait 30-60 seconds for CDN propagation
2. Hard refresh browser (Ctrl+Shift+R)
3. Check Vercel dashboard for deployment status

## Domain Configuration

**CRITICAL**: Only use these domains:
- ‚úÖ www.kimbleai.com
- ‚úÖ kimbleai.com

**NEVER use these subdomains:**
- ‚ùå ai.kimbleai.com
- ‚ùå app.kimbleai.com

All code, documentation, and configuration should reference only the approved domains.

## Deployment Process

### Standard Deployment
```bash
git add .
git commit -m "your commit message"
git push origin master
vercel --prod --yes
```

### Deployment with Version Bump
```bash
# Make your code changes...
# Then:
node scripts/bump-version.js [patch|minor|major]
git add .
git commit -m "your commit message

chore: Bump to v$(node -p "require('./version.json').version")"
git push origin master
vercel --prod --yes
```

## Project-Specific Rules

### Authentication
- Users: zach (zach.kimble@gmail.com) and rebecca (rebecca@kimbleai.com)
- OAuth tokens stored in Supabase `user_tokens` table
- Access tokens expire after 1 hour, use refresh tokens automatically

### Transcription System
- Use AssemblyAI API with key from environment variables
- Database records must be created synchronously before returning response
- Always use `assemblyai_id` for transcript references, not database UUID

### File Structure
- Main page: `app/page.tsx`
- Components: `app/components/`
- API routes: `app/api/`
- Scripts: `scripts/`

### Environment Variables
All environment variables validated pre-build by `scripts/validate-env-whitespace.js`

## Adding Your Own Rules

**LOCATION**: `D:\OneDrive\Documents\kimbleai-v4-clean\.claude.md` (this file)

**TO ADD RULES**:
1. Open this file in any text editor
2. Add a new section with `## Your Section Title`
3. Write your instructions in plain language
4. Save the file
5. Rules take effect immediately in new Claude Code sessions

**EXAMPLE**:
```markdown
## My Custom Rule

Always use TypeScript strict mode and include JSDoc comments for all functions.

### Example
// ‚úÖ Good
/** Calculates the sum of two numbers */
function add(a: number, b: number): number {
  return a + b;
}

// ‚ùå Bad
function add(a, b) {
  return a + b;
}
```

## üìö COMPREHENSIVE PLANNING GUIDE

**See PLANNING.md for complete project planning methodology.**

Key principles:
- Use `/plan` command for new features
- Break work into categories (transcription, calendar, agents, etc.)
- Learn from Archie agent (good: self-contained execution, bad: generic titles)
- Test incrementally, don't build everything at once
- Define success criteria before starting

## üí° CODING BEST PRACTICES (DEFAULT BEHAVIORS)

### Error Handling

**ALWAYS wrap async operations in try-catch:**
```typescript
// ‚úÖ GOOD
async function fetchData() {
  try {
    const result = await api.getData();
    return result;
  } catch (error) {
    console.error('[FETCH-DATA] Error:', error);
    return null;
  }
}

// ‚ùå BAD
async function fetchData() {
  const result = await api.getData(); // Unhandled rejection!
  return result;
}
```

**Include context in error messages:**
```typescript
// ‚úÖ GOOD
console.error('[TRANSCRIPTION-API] Failed to start transcription:', {
  userId,
  fileSize,
  error: error.message
});

// ‚ùå BAD
console.error('Error:', error);
```

### TypeScript Best Practices

**Define interfaces for all data structures:**
```typescript
// ‚úÖ GOOD
interface Transcription {
  id: string;
  text: string;
  speakers: number;
  duration: number;
  created_at: string;
}

// ‚ùå BAD
const transcription: any = { /* ... */ };
```

**Use strict null checks:**
```typescript
// ‚úÖ GOOD
const user = await getUser(userId);
if (!user) {
  return NextResponse.json({ error: 'User not found' }, { status: 404 });
}

// ‚ùå BAD
const user = await getUser(userId);
return NextResponse.json({ data: user.name }); // Potential crash!
```

### React Best Practices

**Use proper hooks dependencies:**
```typescript
// ‚úÖ GOOD
useEffect(() => {
  loadTranscriptions(userId);
}, [userId]); // Depend on userId

// ‚ùå BAD
useEffect(() => {
  loadTranscriptions(userId);
}, []); // Missing dependency
```

**Memoize expensive computations:**
```typescript
// ‚úÖ GOOD
const sortedTranscriptions = useMemo(() => {
  return transcriptions.sort((a, b) => a.created_at - b.created_at);
}, [transcriptions]);

// ‚ùå BAD
const sortedTranscriptions = transcriptions.sort(...); // Sorts on every render!
```

### Database Best Practices

**Always use transactions for multi-step operations:**
```typescript
// ‚úÖ GOOD
const { data, error } = await supabase.rpc('create_project_with_tasks', {
  project_data: { name, description },
  task_data: tasks
});

// ‚ùå BAD
await supabase.from('projects').insert({ name, description });
await supabase.from('tasks').insert(tasks); // Could fail mid-way!
```

**Create database records synchronously in API routes:**
```typescript
// ‚úÖ GOOD
const { data, error } = await supabase
  .from('transcriptions')
  .insert({ id: jobId, status: 'starting' })
  .select()
  .single();

if (error) throw error;

// NOW start background processing
processTranscription(jobId);

// ‚ùå BAD
processTranscription(jobId); // Background, race condition!
await supabase.from('transcriptions').insert(...); // Too late!
```

### API Route Best Practices

**Validate inputs early:**
```typescript
// ‚úÖ GOOD
export async function POST(req: Request) {
  const body = await req.json();

  if (!body.userId || !body.fileUrl) {
    return NextResponse.json(
      { error: 'userId and fileUrl required' },
      { status: 400 }
    );
  }

  // Continue with valid data...
}

// ‚ùå BAD
export async function POST(req: Request) {
  const body = await req.json();
  // Assume data is valid, crash later...
}
```

**Include request context in logs:**
```typescript
// ‚úÖ GOOD
console.log('[TRANSCRIBE-API] Starting transcription:', {
  userId,
  fileSize,
  fileName,
  timestamp: new Date().toISOString()
});

// ‚ùå BAD
console.log('Starting transcription');
```

### Performance Best Practices

**Lazy load heavy components:**
```typescript
// ‚úÖ GOOD
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <Spinner />,
  ssr: false
});

// ‚ùå BAD
import HeavyComponent from './HeavyComponent'; // Loaded always
```

**Debounce user input:**
```typescript
// ‚úÖ GOOD
const debouncedSearch = useDe bounce((query: string) => {
  searchTranscriptions(query);
}, 300);

// ‚ùå BAD
<input onChange={(e) => searchTranscriptions(e.target.value)} />
// Searches on every keystroke!
```

### Security Best Practices

**Never expose sensitive data in client-side code:**
```typescript
// ‚úÖ GOOD
// In API route (server-side)
const apiKey = process.env.ASSEMBLYAI_API_KEY;

// ‚ùå BAD
// In React component (client-side)
const apiKey = process.env.NEXT_PUBLIC_ASSEMBLYAI_API_KEY; // Exposed!
```

**Sanitize user input:**
```typescript
// ‚úÖ GOOD
const sanitized = DOMPurify.sanitize(userInput);

// ‚ùå BAD
dangerouslySetInnerHTML={{ __html: userInput }} // XSS risk!
```

### Testing Best Practices

**Test critical paths:**
```typescript
// ‚úÖ GOOD
describe('Transcription API', () => {
  it('should create database record before processing', async () => {
    const response = await POST(mockRequest);
    expect(response.status).toBe(200);

    const record = await supabase
      .from('transcriptions')
      .select()
      .eq('job_id', jobId)
      .single();

    expect(record.status).toBe('starting');
  });
});
```

**Test error cases, not just happy path:**
```typescript
// ‚úÖ GOOD
it('should return 400 if userId missing', async () => {
  const response = await POST({ body: { fileUrl: 'test.mp3' } });
  expect(response.status).toBe(400);
});
```

### Git Best Practices

**Write descriptive commit messages:**
```bash
# ‚úÖ GOOD
git commit -m "fix: Create transcription DB record synchronously before processing

Fixes race condition where polling requests couldn't find job record
because background processing started before database insert completed.

Changes:
- Move supabase.insert() before processTranscription() call
- Add error handling for insert failures
- Update tests to verify record exists immediately"

# ‚ùå BAD
git commit -m "fix bug"
```

**Commit frequently with logical chunks:**
```bash
# ‚úÖ GOOD
git commit -m "feat: Add transcription download button"
git commit -m "feat: Implement download API endpoint"
git commit -m "feat: Add format selector (txt/docx)"

# ‚ùå BAD
# One giant commit with all changes
```

### Naming Conventions

**Use descriptive, searchable names:**
```typescript
// ‚úÖ GOOD
const MAX_FILE_SIZE_BYTES = 50 * 1024 * 1024; // 50MB
const TRANSCRIPTION_POLL_INTERVAL_MS = 2000;

// ‚ùå BAD
const max = 50000000;
const interval = 2000;
```

**Follow consistent patterns:**
```typescript
// ‚úÖ GOOD - Consistent verb prefixes
async function getTranscription(id: string)
async function createTranscription(data: TranscriptionData)
async function updateTranscription(id: string, data: Partial<TranscriptionData>)
async function deleteTranscription(id: string)

// ‚ùå BAD - Inconsistent naming
async function transcription(id: string) // Get? Create?
async function makeTranscription(data)
async function modifyTranscription(id, data)
async function removeTranscription(id)
```

### Documentation Standards

**Document WHY, not WHAT:**
```typescript
// ‚úÖ GOOD
// Create database record synchronously BEFORE starting background processing
// to prevent race condition where polling requests can't find the job record
const { data, error } = await supabase
  .from('transcriptions')
  .insert({ id: jobId, status: 'starting' });

// ‚ùå BAD
// Insert into database
const { data, error } = await supabase
  .from('transcriptions')
  .insert({ id: jobId, status: 'starting' });
```

**Use JSDoc for functions:**
```typescript
// ‚úÖ GOOD
/**
 * Formats a transcription with speaker labels and timestamps
 * @param transcription - Raw transcription data from AssemblyAI
 * @returns Formatted string with "Speaker N: [HH:MM:SS] text"
 */
function formatTranscription(transcription: Transcription): string {
  // ...
}
```

### Deployment Standards

**Always test locally before deploying:**
```bash
# ‚úÖ GOOD
npm run build  # Test build succeeds
# Manually test the feature
git add .
git commit -m "..."
git push
vercel --prod --yes

# ‚ùå BAD
git add . && git commit -m "fix" && git push && vercel --prod --yes
# No testing!
```

**Bump version after significant changes:**
```bash
# ‚úÖ GOOD
# After adding new feature
node scripts/bump-version.js minor
# Update changelog in version.json
git add version.json
git commit -m "chore: Bump to v1.2.0"

# ‚ùå BAD
# Never update version, deploy with no tracking
```

---

## Tips for Effective Rules

1. **Be Specific**: "Use semantic versioning" is better than "use versions"
2. **Include Examples**: Show what you want, not just describe it
3. **Use Checklists**: Break complex workflows into numbered steps
4. **Reference Files**: Point to specific files/functions when relevant
5. **Update Regularly**: Add new rules as patterns emerge in your project

---

**Last Updated**: 2025-10-23
**Version**: 1.1.0
