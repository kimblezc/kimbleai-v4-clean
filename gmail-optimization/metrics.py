"""
API Quota Monitoring
Generated by Archie - Autonomous Agent

Purpose: Tracks API usage and alerts before hitting Gmail's daily limits
Impact: Prevents quota overruns and service disruptions
Risk Level: LOW
"""

from datetime import datetime, timedelta
from typing import Dict, List, Optional
from dataclasses import dataclass


@dataclass
class QuotaMetric:
    """Represents a single API usage metric"""
    timestamp: datetime
    operation: str
    cost: int  # Number of quota units consumed


class GmailQuotaMonitor:
    """Monitors Gmail API quota usage"""

    # Gmail API daily quota limits
    DAILY_QUOTA_LIMIT = 1000000000  # 1 billion quota units per day
    BATCH_REQUEST_COST = 100  # Quota cost per batch request
    SINGLE_REQUEST_COST = 5    # Quota cost per single request

    def __init__(self):
        """Initialize quota monitor"""
        self.metrics: List[QuotaMetric] = []
        self.daily_usage = 0
        self.last_reset = datetime.now()

    def record_api_call(self, operation: str, is_batch: bool = False) -> None:
        """
        Record an API call and update quota usage.

        Args:
            operation: Type of operation (e.g., 'search', 'fetch', 'delete')
            is_batch: Whether this was a batch request
        """
        cost = self.BATCH_REQUEST_COST if is_batch else self.SINGLE_REQUEST_COST

        metric = QuotaMetric(
            timestamp=datetime.now(),
            operation=operation,
            cost=cost
        )

        self.metrics.append(metric)
        self.daily_usage += cost

        # Check if we need to reset (new day)
        self._check_daily_reset()

    def _check_daily_reset(self) -> None:
        """Reset daily usage if it's a new day"""
        now = datetime.now()
        if now.date() > self.last_reset.date():
            self.daily_usage = 0
            self.last_reset = now
            # Keep only last 7 days of metrics
            cutoff = now - timedelta(days=7)
            self.metrics = [m for m in self.metrics if m.timestamp > cutoff]

    def get_usage_percentage(self) -> float:
        """
        Get current daily usage as percentage of quota.

        Returns:
            Usage percentage (0-100)
        """
        return (self.daily_usage / self.DAILY_QUOTA_LIMIT) * 100

    def get_remaining_quota(self) -> int:
        """
        Get remaining quota for today.

        Returns:
            Remaining quota units
        """
        return max(0, self.DAILY_QUOTA_LIMIT - self.daily_usage)

    def should_throttle(self, threshold: float = 80.0) -> bool:
        """
        Check if we should throttle API calls.

        Args:
            threshold: Percentage at which to start throttling (default 80%)

        Returns:
            True if usage exceeds threshold
        """
        return self.get_usage_percentage() >= threshold

    def get_usage_report(self) -> Dict:
        """
        Generate usage report for monitoring.

        Returns:
            Dictionary with usage statistics
        """
        total_calls = len(self.metrics)
        batch_calls = sum(1 for m in self.metrics if m.cost == self.BATCH_REQUEST_COST)
        single_calls = total_calls - batch_calls

        return {
            'daily_usage': self.daily_usage,
            'daily_limit': self.DAILY_QUOTA_LIMIT,
            'usage_percentage': round(self.get_usage_percentage(), 2),
            'remaining_quota': self.get_remaining_quota(),
            'total_calls_today': total_calls,
            'batch_calls': batch_calls,
            'single_calls': single_calls,
            'should_throttle': self.should_throttle(),
            'reset_time': self.last_reset.isoformat()
        }


if __name__ == '__main__':
    # Test
    print("Testing Gmail quota monitoring...")

    monitor = GmailQuotaMonitor()

    # Simulate API calls
    for i in range(100):
        monitor.record_api_call('search', is_batch=(i % 10 == 0))

    # Get report
    report = monitor.get_usage_report()
    print("\nUsage Report:")
    for key, value in report.items():
        print(f"  {key}: {value}")

    print(f"\nBatch calls saved: {report['single_calls'] * monitor.SINGLE_REQUEST_COST - report['batch_calls'] * monitor.BATCH_REQUEST_COST} quota units")
